---
title: Git Games and Meta Moments
created_at: Mon, 18 Feb 2013 04:06:24 +0000
kind: article
published: true
tags:
- ece2524s13
- git
- meta
- process
- Uncategorized
- vtclis13
---

I had a bit of a meta moment while swimming today. I have a lot of
good moments while swimming, probably because it's a chance for my
mind to wander. That's probably a good argument to go more often than
I did this past week (1 out of 6 possible practice days!). But I
digress.

Yesterday I was introduced to a
[game of sorts](http://pcottle.github.com/learnGitBranching/) to help
learn some concepts used by [git](http://git-scm.com/about). For those
of you who don't know, git is a versioning control system that has
gained quit a bit of popularity over the past few years, especially in
the open source community. I had been using it myself for my own
projects, but mainly at a very simplistic level.

At one level, a versioning control system (VCS), of which git is one
of many, is a tool to facilitate documenting the changes ofâ€¦ well, a
document. Historically these systems were develped by software
designers to both document changes and provide an easy path to revert
to older versions of source code. Later, similar concepts were
implemented in modern word processors (with limited scope and power
due to the restrictive nature, essentially the traditional method of
tracking edits from the pen and paper days was ported over to the
electronic medium without much change).

One thing that became much more clear to me after trying out the git
game was that while providing logical "snapshots" of a project that
can be used as a return point if somethign goes astray in the future,
git is creating a history of the project, a history that tells a
story. But unlike other histories you may be familiar with, the
history generated by git can be rewritten to change the past.

What had alluded me up until this point was what motivation one might
have to rewrite history. I figured, you make changes, commit them to
the project, those changes get recorded, what more would you need?
Well, it turns out that with the ability to rewrite history, git makes
it incredibly easy to do certain types of edits on your data and
allows an author to use git more as a tool for trying out new,
possibly risky ideas, or take off on a tangent while always providing
a clear path back to a ground point.

The details of what these types of edits are are important, but after
I began writing them up I realized I was losing sight of my original
reason for writing this post! Luckily, I have been using git to track
changes to this document, and created a branch for each of the
examples I thought would be useful. I'm going to leave them out of the
final document for now, but they exist in my history, and since I will
post this project to github, you are free to take a look!

What I thought about while swimming, after the git game helped me
understand why rewriting history could be so useful, and how the
history itself could be used, was that since I'm using git to manage
the files for ECE2524, I could also use it guide future semesters of
the course. Every time I add a new set of lecture notes, or add a new
assignment, I make a commit to a git repo containing all the files
I've used so far. That is also recording the order in which topics are
introduced to the class, so I'm generating an outline for the semester
just by nature of using git for your regular garden variety versioning
control.

But I had an hour and a half to occupy my brain while I swam back and
forth, so the wheels kept turning. We use git for class, as those of
you in it know, because it is an important tool for software
development and happens to be a particularly Unix-y tool to boot. The
Unix-i-ness of git is something I will leave for discussion in class
tomorrow (oh, the suspense!). We use git, but it is a complicated tool
to learn, even though what it is doing is quite simple, once you
[grok](http://en.wikipedia.org/wiki/Grok) it, something that doesn't
always happen quickly, and never as quickly as you would like.

But the information tracking ideas from git can be related to the
process we go through in class, which can also be related to the
discussion on working memory vs. long-term memory we had in
[vtlci](http://gardnercampbell.wetpaint.com/page/vtclis13). The
process of learning new things involves some experimentation and a lot
of data filtering. We have a lot of information available to us, the
culmination of which can be thought of as the contents of our "working
directory" in git terms. As we individually work through the
information and inspect it through our own lens we commit pieces of it
to our memory, our repository. Though we're not actively doing it,
there is a log associated with this process. It is not as precise as
something stored on a computer, of course, but looking back on the
past few days we can recall things like "concept X made a lot more
sense to me after I understood hypothesis Y, which became clear after
working through exercise Z."

What if we were more conscious of this process in class, and even made
an effort to map it more directly to the concept of using git? For
instance, one versioning control concept we'll start to explore
tomorrow is branching and merging.

A branch can be thought of as a temporary deviation away from the main
story line. In fact, in my first paragraph I went off on a bit of a
tangent about my tendency to let my mind wander while swimming. That
could be thought of as a branch away from the main topic, which (I
promise) is about using git to map the journey we take to learn to use
git. In fact, I switched to a new branch in git when I began writing
those sentences, and then merged them back into the main conversation
when I was done.

What if the class were split up into groups, and each group worked on
one aspect of learning to use git's branch and merge
functionality. For instances, Group 1 might play the git game, while
group 2 might read about how git represents and references data and
what is going on under the hood. At that point, the collective commit
knowledge of the class will have split into two branches. One branch
with more of a pragmatic grasp of "this is how I do a branch and
merge" and another branch with a better understanding of "this is how
a branch and a merge is implemented by git". Then, the following week,
both groups would come back together and share what each learned. The
two groups will have just "merged" their knowledge and everyone should
have a better understanding of how to conduct a branch and a merge,
and also what is going on with the underlying data structure when they
do one.

Oh, and by the way, when writing that last paragraph I created two new
branches: one named "group1" and it contained the description of what
the hypothetical group1 would do, and another called "group2" which
contained the sentance describing that group's task. Then I merged the
two back into the master branch, reformated the paragraph and add a
summary. Check out this history on github!

So this whole process got me thinking. Does thinkging about meta
thoughts make it easier or more likely to think about meta thoughts in
the future? And likewise, does it make it easier to draw comparisons
between seemingly unrelated processes, such as learning new ideas, and
software development, when you have a process and a vocabulary to
describe the process of each?
[I _am_ a strange loop](http://bit.ly/YAAQ7a).

